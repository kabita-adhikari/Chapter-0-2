{"title":"Chapter 0.2","markdown":{"yaml":{"title":"Chapter 0.2","format":{"html":{"toc":true,"toc-depth":3,"toc-expand":4,"number-sections":true,"code-block-bg":true,"code-block-border-left":true}}},"headingText":"Behind the Scenes in Java","containsRefs":false,"markdown":"\n\n## Memory\nIf the discussion in this section is a bit too difficult for you to understand, please refer to the last Computer Architecture discussion we had in CSC132. Recall that during our discussion of how a computer works, we talked about the makeup of memory. At a very basic level, memory is made up of “words” which is a unit of memory. Each word has a specific address, and is used to store both data and the instructions that work upon that data. The diagram below shows a sample memory space with 256 words.\n\n![](images/one.svg){width=30%}\n<br>\n\n\n</br>\n\n\n## Storing variables\nThe operating system is in charge of mapping variables to addresses and the data stored in that address and there are two main ways that it does this.  \nWith <b>direct addressing </b>, the location associated with the variable stores the value of that variable. This is typically the case with primitive data types e.g. characters, int, float, long, etc. The variable is said to be stored by value.   \nWith <b>indirect addressing</b>, the location associated with the variable stores the address of another location that has the actual value. Think of it as the memory location is storing the keys of the actual place where the value is stored. This is typically the case with complex data types e.g. strings, objects created from classes, etc. The variable is said to be stored by reference.  \n\n![](images/two.svg){width=50%}\n\n```{.default}\nchar ch = ‘a’; //direct addressing    \nString str = “dog”;     \n\n/*\nindirect addressing. str has the address 03 and the actual value is found at that address. \nThis consists of the data plus some extra information that could help with some extra manipulation.   \n    \nThis is sometimes represented as    \n\n                str -> dog  \n    \n**spoiler alert: This arrow representation will come back later when we discuss linked lists.*/\n\n```\n\n## What does this mean for our programming?\n### Creating objects\n\n``` { .default }\n// This is a basic class representing a circle All it stores is the radius. \n// It has a constructor, an accessor and a mutator.\nclass Circle\n{\n    private int radius;\n\n    public Circle(int radius)\n    {\n        setRadius(radius);\n    }\n\n    public void setRadius(int radius)\n    {\n        if (radius>=0)\n            this.radius = radius;\n        else\n            this.radius =1;\n    }\n\n    public int getRadius()\n    {\n        return this.radius;\n    }\n    \n    public String toString()\n    {\n        return \"This circle has a radius of \" + this.getRadius();\n    }\n}\n```\nGiven the Circle class defined above, let’s write some lines of code and see what happens in memory, and how it can be represented diagramatically. We shall also be manipulating a primitive type (int) so that you can notice the contrast between the two.\n``` { .default }\n// Simple declaration of two variables. \n// One is an object of type Circle and the other is a primitive integer\nCircle a; \nint x;  \n```\n![](images/3.svg){width=40%}\n    \nNotice that without any initialization, Java will put some default values in those memory locations. For objects, the default value is null to mean the lack of a reference (or address). The default value for ints is 0.\n\nFYI null can also be used in object comparison\n```{.default}\nif (a== null)\n    System.out.println(“Circle has not been initialized”);\n```\n\n\n``` {.default}\n// Assigning initial values to both a and x. \n// For a, this involves creating a circle object and passing it any required  parameters.\n\na = new Circle(5); \nx = 5; \n```\n    \n![](images/4.svg){width=40%}\n\n\nWhile the location associated with x stores the actual value of x (i.e. 5), the location associated with a stores the address of a location in memory (12AB) where the information representing the circle object is actually stored. This means x is stored by value, and a is stored by reference. Declaration and Initialization can also be done in a single step.\n\n```{.default}\nCircle b = new Circle(7);\nint y = 7;\n```\n\n![](images/5.svg){width=65%}  \n\n\nBoth a and b are objects and therefore are stored by reference while x and y which are primitive types are stored by value.\n\n\n### Assigning objects\nWhen a primitive type is assigned, the value stored in the location is copied to the new location.\n\n```{.default}\nx = y;      // This copies the value that was in y into x.\na = b;      // This copies the reference stored in b into a\n```\nHowever, when an object is assigned, whatever is stored in the source location is copied into the target location. Recall that an address/reference is actually what is stored and not the actual value. Therefore object assignment has the unique effect of making both variables refer to the same copy of the object instead of having two copies of the object.\n\n![](images/6.svg){width=65%}\n\n\n\nThere are a couple of implications of this behavior.\n\n- Firstly, the original circle located at 12AB is no longer accessible. The memory location is being used to store the circle, but that circle can no longer be used since there is no way to get to it. The space it takes up is now referred to as garbage. Java automatically cleans garbage(garbage collection) so that the computer/program has access to that memory eventually. This is not the case in other languages.\n```{.default}\nCircle c;\nfor (int n = 0; n < 100; n++)\n{\n    c = new Circle(n*2); // create a circle with a radius twice the size of n\n}\n/* Notice that when this loop finishes execution, you will only have access to the last\ncreated circle and not the 99 circles before that (which now constitute garbage) */\n```\n- Secondly, and perhaps more importantly, since a and b refer to the exact same circle (there are two keys to the same house), then any changes made to the copy a (whether intentional or accidental) also affect the original b.\n\n### Objects as parameters to functions/methods\nThat last point we discussed might seem very small and avoidable but in reality it isn’t. That’s because whenever an object is passed as a parameter in a function, it is passed by reference. So even if it might have another variable name in the function, any changes to the object will affect the original object.\n\n```{.default}\nclass Test\n{\n    public static void main(String [] args)\n    {\n        Circle a, b, c;\n        a = new Circle(3);\n        b = new Circle(5);\n        c = combinedCircle(a, b);\n        System.out.println(a); // a will have a radius of 10 because it was changed\n        System.out.println(b); // “unintentionally” in the combinedCircle function.\n        System.out.println(c);\n        }\n    public static Circle combinedCircle ( Circle x, Circle y)\n    {\n        Circle z = new Circle(x.getRadius() + y.getRadius());\n        x.setRadius(10);      // statement that changes one of the input arguments, and \n                              // inadvertently changes the original copy in the process.\n        return z;\n    }\n}\n```\n### Arrays\nWe have mentioned how primitive types are stored and passed (i.e. by value) and how objects are stored and passed (i.e. by reference). But what about arrays? Recall that with primitive types, the variable name is mapped directly to a memory location that contains the value associated with that variable (by value). Conversely, with objects, the variable name is mapped to a memory location that contains the address of another place in memory where the object state is being stored (by reference). Arrays (of any type) are treated like objects. That means that the array name is mapped to a memory location that contains the address of the first of a block of memory locations that contain the array elements i.e. arrays are passed by reference. This means that if you pass an array as an argument to a function, that function is in fact dealing with the original array and therefore any changes to the array will last even after control has been passed back to the original function.\n\n```{.default}\nimport java.util.*\nclass Trial\n{\n    public static void main(String [] args)\n    {\n        Random r = new Random();\n        int [] arr = new int [100]; // create an array of 100 integers (by default all set to 0)\n        for (int i = 0; i < arr.length; i++)\n        arr[i] = r.nextInt(1000);   // random integer from 0-1000\n        // Sort the array\n        selectionSort(arr); // Note that this function only takes an argument and does not return\n                            // any values. Nonetheless, it is capable of making changes to the \n                            // original array since it has the reference to that array.\n        // Print out the array\n        for (int i = 0; i < arr.length; i++)\n        System.out.print(arr[i] + “ “);\n    }\n    public static void selectionSort(int [] list)\n    {\n        // a sort function that doesn’t have a return type (i.e. void) but actually affects the \n        // variable in the original function. So in an essence it does return something\n    }\n}\n```\nNotice in the example above how the selectionSort function doesn’t have a return type but is still able to affect a variable in the original main function.\n\n### Arrays of Objects\nOccasionally, it is necessary to create an array of objects. If objects are mapped by reference, and arrays are mapped by reference, then what about arrays of objects?\n```{.default}\nint [] arr = new int [10]; // an array of primitives (for comparison)\nCircle [] circles = new Circle [10];  // an array of circle objects which by default are all set\n                                     // null. Any of the circle elements can now be initialized.\ncircles[0] = new Circle(5);\ncircles[4] = new Circle(8);\n```\nThe variable name of the array will store the first address of a block of memory cells that have been set aside to store addresses for the objects. Think of it as circles is storing a key, and that key opens a chest of drawers each of which has another key to a circle in another location. Incidentally, this idea of a variable name storing a reference to an array of references is the same way a multidimensional array is dealt with.\n\n```{.default}\nint [][] arr = new int [4][10];       // a 2D array of 4 rows and 10 columns.\narr[2][8] = 103;                     // store the value 103 in the 3rd row and 9th column.\n```\nIn the example above, arr is storing a key. That key opens up a row of drawers. In each of those drawers is another key that opens up a row of drawers where the values are actually kept. In more official terms, arr is a reference to a single dimensional array that contains references. Each of those references gives access to their own single dimensional array of values. So a 2D array is an array of arrays.\n\n<br>\n\n\n            \n            \n</br>\n\n\n\nReferences:     \nObject Oriented Data Structures using Java (4th Edition). Nell Dale, Daniel T. Joyce, Chip Weems.\n\n\n\n\n ","srcMarkdownNoYaml":"\n# Behind the Scenes in Java\n\n## Memory\nIf the discussion in this section is a bit too difficult for you to understand, please refer to the last Computer Architecture discussion we had in CSC132. Recall that during our discussion of how a computer works, we talked about the makeup of memory. At a very basic level, memory is made up of “words” which is a unit of memory. Each word has a specific address, and is used to store both data and the instructions that work upon that data. The diagram below shows a sample memory space with 256 words.\n\n![](images/one.svg){width=30%}\n<br>\n\n\n</br>\n\n\n## Storing variables\nThe operating system is in charge of mapping variables to addresses and the data stored in that address and there are two main ways that it does this.  \nWith <b>direct addressing </b>, the location associated with the variable stores the value of that variable. This is typically the case with primitive data types e.g. characters, int, float, long, etc. The variable is said to be stored by value.   \nWith <b>indirect addressing</b>, the location associated with the variable stores the address of another location that has the actual value. Think of it as the memory location is storing the keys of the actual place where the value is stored. This is typically the case with complex data types e.g. strings, objects created from classes, etc. The variable is said to be stored by reference.  \n\n![](images/two.svg){width=50%}\n\n```{.default}\nchar ch = ‘a’; //direct addressing    \nString str = “dog”;     \n\n/*\nindirect addressing. str has the address 03 and the actual value is found at that address. \nThis consists of the data plus some extra information that could help with some extra manipulation.   \n    \nThis is sometimes represented as    \n\n                str -> dog  \n    \n**spoiler alert: This arrow representation will come back later when we discuss linked lists.*/\n\n```\n\n## What does this mean for our programming?\n### Creating objects\n\n``` { .default }\n// This is a basic class representing a circle All it stores is the radius. \n// It has a constructor, an accessor and a mutator.\nclass Circle\n{\n    private int radius;\n\n    public Circle(int radius)\n    {\n        setRadius(radius);\n    }\n\n    public void setRadius(int radius)\n    {\n        if (radius>=0)\n            this.radius = radius;\n        else\n            this.radius =1;\n    }\n\n    public int getRadius()\n    {\n        return this.radius;\n    }\n    \n    public String toString()\n    {\n        return \"This circle has a radius of \" + this.getRadius();\n    }\n}\n```\nGiven the Circle class defined above, let’s write some lines of code and see what happens in memory, and how it can be represented diagramatically. We shall also be manipulating a primitive type (int) so that you can notice the contrast between the two.\n``` { .default }\n// Simple declaration of two variables. \n// One is an object of type Circle and the other is a primitive integer\nCircle a; \nint x;  \n```\n![](images/3.svg){width=40%}\n    \nNotice that without any initialization, Java will put some default values in those memory locations. For objects, the default value is null to mean the lack of a reference (or address). The default value for ints is 0.\n\nFYI null can also be used in object comparison\n```{.default}\nif (a== null)\n    System.out.println(“Circle has not been initialized”);\n```\n\n\n``` {.default}\n// Assigning initial values to both a and x. \n// For a, this involves creating a circle object and passing it any required  parameters.\n\na = new Circle(5); \nx = 5; \n```\n    \n![](images/4.svg){width=40%}\n\n\nWhile the location associated with x stores the actual value of x (i.e. 5), the location associated with a stores the address of a location in memory (12AB) where the information representing the circle object is actually stored. This means x is stored by value, and a is stored by reference. Declaration and Initialization can also be done in a single step.\n\n```{.default}\nCircle b = new Circle(7);\nint y = 7;\n```\n\n![](images/5.svg){width=65%}  \n\n\nBoth a and b are objects and therefore are stored by reference while x and y which are primitive types are stored by value.\n\n\n### Assigning objects\nWhen a primitive type is assigned, the value stored in the location is copied to the new location.\n\n```{.default}\nx = y;      // This copies the value that was in y into x.\na = b;      // This copies the reference stored in b into a\n```\nHowever, when an object is assigned, whatever is stored in the source location is copied into the target location. Recall that an address/reference is actually what is stored and not the actual value. Therefore object assignment has the unique effect of making both variables refer to the same copy of the object instead of having two copies of the object.\n\n![](images/6.svg){width=65%}\n\n\n\nThere are a couple of implications of this behavior.\n\n- Firstly, the original circle located at 12AB is no longer accessible. The memory location is being used to store the circle, but that circle can no longer be used since there is no way to get to it. The space it takes up is now referred to as garbage. Java automatically cleans garbage(garbage collection) so that the computer/program has access to that memory eventually. This is not the case in other languages.\n```{.default}\nCircle c;\nfor (int n = 0; n < 100; n++)\n{\n    c = new Circle(n*2); // create a circle with a radius twice the size of n\n}\n/* Notice that when this loop finishes execution, you will only have access to the last\ncreated circle and not the 99 circles before that (which now constitute garbage) */\n```\n- Secondly, and perhaps more importantly, since a and b refer to the exact same circle (there are two keys to the same house), then any changes made to the copy a (whether intentional or accidental) also affect the original b.\n\n### Objects as parameters to functions/methods\nThat last point we discussed might seem very small and avoidable but in reality it isn’t. That’s because whenever an object is passed as a parameter in a function, it is passed by reference. So even if it might have another variable name in the function, any changes to the object will affect the original object.\n\n```{.default}\nclass Test\n{\n    public static void main(String [] args)\n    {\n        Circle a, b, c;\n        a = new Circle(3);\n        b = new Circle(5);\n        c = combinedCircle(a, b);\n        System.out.println(a); // a will have a radius of 10 because it was changed\n        System.out.println(b); // “unintentionally” in the combinedCircle function.\n        System.out.println(c);\n        }\n    public static Circle combinedCircle ( Circle x, Circle y)\n    {\n        Circle z = new Circle(x.getRadius() + y.getRadius());\n        x.setRadius(10);      // statement that changes one of the input arguments, and \n                              // inadvertently changes the original copy in the process.\n        return z;\n    }\n}\n```\n### Arrays\nWe have mentioned how primitive types are stored and passed (i.e. by value) and how objects are stored and passed (i.e. by reference). But what about arrays? Recall that with primitive types, the variable name is mapped directly to a memory location that contains the value associated with that variable (by value). Conversely, with objects, the variable name is mapped to a memory location that contains the address of another place in memory where the object state is being stored (by reference). Arrays (of any type) are treated like objects. That means that the array name is mapped to a memory location that contains the address of the first of a block of memory locations that contain the array elements i.e. arrays are passed by reference. This means that if you pass an array as an argument to a function, that function is in fact dealing with the original array and therefore any changes to the array will last even after control has been passed back to the original function.\n\n```{.default}\nimport java.util.*\nclass Trial\n{\n    public static void main(String [] args)\n    {\n        Random r = new Random();\n        int [] arr = new int [100]; // create an array of 100 integers (by default all set to 0)\n        for (int i = 0; i < arr.length; i++)\n        arr[i] = r.nextInt(1000);   // random integer from 0-1000\n        // Sort the array\n        selectionSort(arr); // Note that this function only takes an argument and does not return\n                            // any values. Nonetheless, it is capable of making changes to the \n                            // original array since it has the reference to that array.\n        // Print out the array\n        for (int i = 0; i < arr.length; i++)\n        System.out.print(arr[i] + “ “);\n    }\n    public static void selectionSort(int [] list)\n    {\n        // a sort function that doesn’t have a return type (i.e. void) but actually affects the \n        // variable in the original function. So in an essence it does return something\n    }\n}\n```\nNotice in the example above how the selectionSort function doesn’t have a return type but is still able to affect a variable in the original main function.\n\n### Arrays of Objects\nOccasionally, it is necessary to create an array of objects. If objects are mapped by reference, and arrays are mapped by reference, then what about arrays of objects?\n```{.default}\nint [] arr = new int [10]; // an array of primitives (for comparison)\nCircle [] circles = new Circle [10];  // an array of circle objects which by default are all set\n                                     // null. Any of the circle elements can now be initialized.\ncircles[0] = new Circle(5);\ncircles[4] = new Circle(8);\n```\nThe variable name of the array will store the first address of a block of memory cells that have been set aside to store addresses for the objects. Think of it as circles is storing a key, and that key opens a chest of drawers each of which has another key to a circle in another location. Incidentally, this idea of a variable name storing a reference to an array of references is the same way a multidimensional array is dealt with.\n\n```{.default}\nint [][] arr = new int [4][10];       // a 2D array of 4 rows and 10 columns.\narr[2][8] = 103;                     // store the value 103 in the 3rd row and 9th column.\n```\nIn the example above, arr is storing a key. That key opens up a row of drawers. In each of those drawers is another key that opens up a row of drawers where the values are actually kept. In more official terms, arr is a reference to a single dimensional array that contains references. Each of those references gives access to their own single dimensional array of values. So a 2D array is an array of arrays.\n\n<br>\n\n\n            \n            \n</br>\n\n\n\nReferences:     \nObject Oriented Data Structures using Java (4th Edition). Nell Dale, Daniel T. Joyce, Chip Weems.\n\n\n\n\n "},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":3,"number-sections":true,"output-file":"Chapter0_2.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","title":"Chapter 0.2","toc-expand":4,"code-block-bg":true,"code-block-border-left":true},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}